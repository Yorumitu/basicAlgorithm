package sortingAlgorithm.Top10Sorting;

/**
 * 快速排序
 * 基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，
 * 其中一部分的所有数据都比另外一部分的所有数据都要小，
 * 然后再按此方法对这两部分数据分别进行快速排序，
 * 整个排序过程可以递归进行，以此达到整个数据变成有序序列。
 *
 * 在数组中找一个支点(任意),经过一趟排序后，支点左边的数都要比支点小，支点右边的数都要比支点大
 * ij终究会会和，他们保证了ij相遇位置两边的元素的大小关系，那个位置不一定是原支点的位置，那个点两边的元素也不一定都大于或小于支点，但是一边的元素必然大于另一边
 *
 * 一下详细部分参照：https://blog.csdn.net/qq_38289815/article/details/82718428
 *
 * 快速排序的运行时间与划分是否对称有关。最坏情况下，每次划分过程产生两个区域分别包含n-1个元素和1个元素，其时间复杂度会达到O(n^2)。
 * 在最好的情况下，每次划分所取的基准都恰好是中值，即每次划分都产生两个大小为n/2的区域。此时，快排的时间复杂度为O(nlogn)。
 * 所以基准的选择对快排而言至关重要。
 * 三种基准选择方法：
 *      固定基准：
 *          如果数组元素是随机的，划分过程不产生极端情况，那么程序的运行时间不会有太大的波动。
 *          如果数组元素已经基本有序时，此时的划分就容易产生最坏的情况，即快速排序变成冒泡排序，时间复杂度为O(n^2)。
 *          直接固定基准取中点的话，如果数据量过大可能溢出
 *      随机基准
 *          在待排数组有序或基本有序的情况下，选择使用固定基准影响快排的效率。为了解决数组基本有序的问题，可以采用随机基准的方式来化解这一问题。
 *          由于随机基准选取的随机性，使得它并不能很好的适用于所有情况(即使是同一个数组，多次运行的时间也大有不同)。
 *      三数取中
 *          它的思想是：选取数组开头，中间和结尾的元素，通过比较，选择中间的值作为快排的基准。其实可以将这个数字扩展到更大(例如5数取中，7数取中等)。
 *          这种方式能很好的解决待排数组基本有序的情况，而且选取的基准没有随机性。
 *
 * 优化思路：
 *  优化1：序列长度达到一定大小时，使用插入排序
 *      当快排达到一定深度后，划分的区间很小时，再使用快排的效率不高。当待排序列的长度达到一定数值后，可以使用插入排序。
 *      由《数据结构与算法分析》(Mark Allen Weiness所著)可知，当待排序列长度为5~20之间，此时使用插入排序能避免一些有害的退化情形。
 *      在划分到很小的区间时，里面的元素已经基本有序了，再使用快排，效率就不高了。所以，在结合插入排序后，程序的执行效率有所提高。
 *  优化2：尾递归优化
 *      快排算法和大多数分治排序算法一样，都有两次递归调用。
 *      但是快排与归并排序不同，归并的递归则在函数一开始， 快排的递归在函数尾部，这就使得快排代码可以实施尾递归优化。
 *      使用尾递归优化后，可以缩减堆栈的深度，由原来的O(n)缩减为O(logn)。
 *
 *  优化3：聚集元素
 *      聚集元素的思想：在一次分割结束后，将与本次基准相等的元素聚集在一起，再分割时，不再对聚集过的元素进行分割。
 *          具体过程有两步，①在划分过程中将与基准值相等的元素放入数组两端，②划分结束后，再将两端的元素移到基准值周围。
 *      通过对快排聚集元素的优化，在处理数组中的重复元素时有很大的提升。
 *      而对于升序数组而言，因为其本身就是有序的，而且没有重复元素，所以结果没有(三数取中+插排)效率高。
 *
 *  优化4：多线程处理快排
 *      分治法的基本思想是将一个规模为n的问题分解为k个规模较小的子问题，这些子问题互相独立且与原问题相同。
 *      求解这些子问题，然后将各子问题的解合并，从而得到的原问题的解。由此，在处理快排的时候，可以使用多线程提高排序的效率。
 *
 *      结合了多线程的快排(三数+插排+多线程)在处理前三种数组时都有明显的提升。
 *      重复数组处理时间增加的原因是：聚集元素在处理重复数组时的表现已经很好了，因为在多线程的组合中，各个线程排完序后要合并，所以增加了(三数+插排+多线程)这一组合的排序时间。
 *      因为时间原因，以上的数据，是运行相应代码10次所取得平均值。
 *      如果想要得到更精确的数据，需要大量的运行上述代码(即使存在一些不稳定的数据，也不会影响到代码优化的方向)。
 *
 *
 * 尾递归概念：
 *
 * 如果一个函数中所有递归形式的调用都出现在函数的末尾，当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。
 * 尾递归函数的特点是在回归过程中不用做任何操作，这个特性很重要，因为大多数现代的编译器会利用这种特点自动生成优化的代码。
 *
 * 尾递归原理：
 * 当编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活动记录而不是在栈中去创建一个新的。
 * 编译器可以做到这点，因为递归调用是当前活跃期内最后一条待执行的语句，于是当这个调用返回时栈帧中并没有其他事情可做，因此也就没有保存栈帧的必要了。
 * 通过覆盖当前的栈帧而不是在其之上重新添加一个，这样所使用的栈空间就大大缩减了，这使得实际的运行效率会变得更高。
 *
 *
 */
public class QuickSort {
    /**
     * 快速排序
     *
     * @param arrays
     * @param L   指向数组第一个元素
     * @param R   指向数组最后一个元素
     */
    public static void quickSort(int[] arrays, int L, int R) {
        //找一个支点
        int mid = arrays[(L + R)/2];
        int i = L, j = R;
        //通过循环将大于和小于mid的元素分别放在两边
        while(i < j) {
            //找到大于支点的数
            while(mid > arrays[i]) {
                i++;
            }
            //寻找小于支点的数
            while(mid < arrays[j]){
                j--;
            }
            //此时已经找到了两个比支点大、小的两个数，交换
            if (i <= j) {
                int temp = arrays[i];
                arrays[i] = arrays[j];
                arrays[j] = temp;
                i++;
                j--;
            }
            //递归调用
            if (L < j) quickSort(arrays, L, j);
            if (R > i) quickSort(arrays, i, R);
        }
    }

    public static void main(String[] args) {
        int[] arrays = {2, 3, 1, 4, 3, 5, 1, 6, 1, 2, 3, 7, 2, 3};
        quickSort(arrays, 0, arrays.length-1);
        for (int i: arrays) {
            System.out.println(i);
        }
    }
}
